(**************************)
(**************************)
(**        Ideals        **)
(**************************)
(**************************)





(**************************)
(* Requirements           *)
(**************************)

require import AllCore List Ring StdRing.
require (*--*) Bigalg.

clone include Ring.ComRing.

clone import Bigalg.BigComRing with
  type t <- t,
  pred CR.unit   <- Top.unit,
    op CR.zeror  <- Top.zeror,
    op CR.oner   <- Top.oner,
    op CR.( + )  <- Top.( + ),
    op CR.([-])  <- Top.([-]),
    op CR.( * )  <- Top.( * ),
    op CR.invr   <- Top.invr,
    op CR.intmul <- Top.intmul,
    op CR.ofint  <- Top.ofint,
    op CR.exp    <- Top.exp

    proof CR.*

    remove abbrev CR.(-)
    remove abbrev CR.(/).

realize CR.addrA      by apply Top.addrA    .
realize CR.addrC      by apply Top.addrC    .  
realize CR.add0r      by apply Top.add0r    . 
realize CR.addNr      by apply Top.addNr    . 
realize CR.oner_neq0  by apply Top.oner_neq0. 
realize CR.mulrA      by apply Top.mulrA    . 
realize CR.mulrC      by apply Top.mulrC    . 
realize CR.mul1r      by apply Top.mul1r    . 
realize CR.mulrDl     by apply Top.mulrDl   . 
realize CR.mulVr      by apply Top.mulVr    . 
realize CR.unitP      by apply Top.unitP    . 
realize CR.unitout    by apply Top.unitout  . 

instance ring with t
  op rzero = Top.zeror
  op rone  = Top.oner
  op add   = Top.( + )
  op opp   = Top.([-])
  op mul   = Top.( * )
  op expr  = Top.exp

  proof oner_neq0 by apply/oner_neq0
  proof addr0     by apply/addr0
  proof addrA     by apply/addrA
  proof addrC     by apply/addrC
  proof addrN     by apply/addrN
  proof mulr1     by apply/mulr1
  proof mulrA     by apply/mulrA
  proof mulrC     by apply/mulrC
  proof mulrDl    by apply/mulrDl
  proof expr0     by apply/expr0
  proof exprS     by apply/exprS.

(* -------------------------------------------------------------------- *)
hint simplify expr0, expr1.

(* There is a Binomial.ec file in the std library that seems incomplete *)
op c : int -> int -> int.

lemma cn0 n : c n 0 = 1 by admit.
lemma cnn n : c n n = 1 by admit.

lemma ge0_c n m : 0 <= c n m by admit.

lemma PascalTriangle n k :
  0 <= n => 0 <= k < n => c n k + c n (k+1) = c (n+1) (k+1).
proof. admitted.

lemma mulrDz (x : t) (n m : int) : intmul x (n + m) = intmul x n + intmul x m.
proof. admitted.

lemma binomial x y n : 0 <= n => exp (x + y) n =
  BAdd.bigi predT (fun i => intmul (exp x i * exp y (n - i)) (c n i)) 0 (n + 1).
proof.
elim: n => [|i ge0_i ih].
+ by rewrite BAdd.big_int1 /= mul1r cn0 mulr1z.
rewrite exprS // ih /= mulrDl 2!BAdd.mulr_sumr.
rewrite (BAdd.big_addn 1 _ (-1)) /= (BAdd.big_int_recr (i+1)) 1:/# /=.
pose s1 := BAdd.bigi _ _ _ _; rewrite cnn mulr1z mulr1 -exprS // addrAC.
apply: eq_sym; rewrite (BAdd.big_int_recr (i+1)) 1:/# /= cnn mulr1z mulr1.
congr; apply: eq_sym; rewrite (BAdd.big_int_recl _ 0) //=.
rewrite cn0 mulr1z mul1r -exprS // addrCA addrC; apply: eq_sym.
rewrite (BAdd.big_int_recl _ 0) //= cn0 mulr1z mul1r addrC.
congr; apply: eq_sym; rewrite /s1 => {s1}.
rewrite !(BAdd.big_addn 1 _ (-1)) /= -BAdd.big_split /=.
rewrite !BAdd.big_seq &(BAdd.eq_bigr) => /= j /mem_range rg_j.
rewrite mulrnAr ?ge0_c mulrA -exprS 1:/# /= addrC.
rewrite mulrnAr ?ge0_c mulrCA -exprS 1:/#.
rewrite IntID.addrAC IntID.opprB IntID.addrA.
rewrite -mulrDz; congr; rewrite IntID.addrC.
by rewrite (PascalTriangle i (j-1)) 1,2:/#.
qed.

(**************************)
(* Operators              *)
(**************************)

(*Ideal*)
op ideal (i : t -> bool) : bool =
   (exists x : t , i x)
/\ (forall x y : t , i x => i y => i (x-y))
/\ (forall x y : t , i x => i (x * y)).

lemma idealP (i : t -> bool) :
    (exists x, i x)
 => (forall x y, i x => i y => i (x-y))
 => (forall x y, i x => i (x * y))
 => ideal i.
proof. by move=> *; do! split. qed.

lemma idealW (P : (t -> bool) -> bool) :
  (forall i,
        (exists x, i x)
     => (forall (x y : t), i x => i y => i (x-y))
     => (forall x y, i x => i (x * y))
     => P i)
  => forall i, ideal i => P i.
proof. by move=> ih i [? [??]]; apply: ih. qed.

(*The zero ideal*)
op zeroId : t -> bool = pred1 zeror.

(*The whole ring ideal*)
op ringId : t -> bool = predT.

(*Intersection of two ideals*)
op interId ( i j : t -> bool ) : t -> bool =
  predI i j.

(*Sum of two ideals*)
op sumId ( i j : t -> bool ) : t -> bool =
  fun z => exists (x y : t), (z = x + y) /\ i x /\ j y.

(*Quotient of two ideals*)
op quoId ( i j : t -> bool ) : t -> bool =
  fun x => (forall y , j y => i (x * y)).

(*Ideal generated by a subset*)
op genId ( i : t -> bool ) : t -> bool =
  fun x =>
    exists l : (t * t) list ,
         ( x = foldr ( + ) zeror (unzip2 (amap ( * ) l)) )
      /\ ( foldr (fun a => fun b => (i a) /\ b) true (unzip1 l) ).


(*
op genId (P : t list) : t -> bool = fun x =>
  exists (vs : t list), x =
    BAdd.bigi predT (fun i => nth zeror vs i * nth zeror P i) 0 (size P).

lemma genidP (P : t -> bool) :
  exists (I : t -> bool),
       ideal I
    /\ P <= I
    /\ forall J, ideal J => P <= J => I <= J.
proof. admitted.
*)

(*Product of two ideals*)
op prodId ( i j : t -> bool ) : t -> bool =
  genId (fun z => exists (x y : t), (z = x * y) /\ i x /\ j y).

(*Radical of two ideals*)
op radId ( i : t -> bool ) : t -> bool =
  fun x => exists n : int , 0 <= n /\ i (exp x n).

(*Principal ideal*)
op principal ( i : t -> bool ) : bool =
  exists x : t , i = genId (pred1 x).

(*Finitely generated ideal*)
op finitelyGenerated ( i : t -> bool ) : bool =
  exists lx : t list , (lx <> []) /\ (i = genId (mem lx)).



(**************************)
(* Lemmas                 *)
(**************************)


(*zeror is in any ideal*)
lemma zeroInId : forall i , ideal i => i zeror.
proof.
by elim/idealW=> i [x ix] /(_ _ _ ix ix); rewrite subrr.
(*
move => i [existsxInId [substStabId multStabId]].
case existsxInId.
move => x xIni.
rewrite - (subrr x).
rewrite (substStabId x x).
by exact xIni.
by exact xIni.
*)
qed.

(*Ideals are not empty*)
lemma existsxInId : forall i , ideal i => exists x , i x.
proof.
by move=> i /zeroInId ?; exists zeror.
(*
move => i [existsxInId [substStabId multStabId]].
by exact existsxInId.
*)
qed.

(*Ideals are stable by substraction*)
lemma substStabId : forall i , ideal i => forall x y  , i x => i y => i (x-y).
proof.
by elim/idealW.
(*
move => i [existsxInId [substStabId multStabId]].
by exact substStabId.
*)
qed.

(*Ideals are stable by multiplication by an element of the ring*)
lemma multStabId : forall i , ideal i => forall x y  , i x => i (x * y).
proof.
by elim/idealW.
qed.

(*The zero ideal is an ideal*)
(*This proof would be more elegant if I could split in three the conjunction immediatly.*)
lemma zeroIdIsId : ideal zeroId.
proof.
apply: idealP.
+ by exists zeror.
+ by move=> x y @/zeroId -> ->; rewrite subr0.
+ by move=> x y @/zeroId ->; rewrite mul0r.
(*
split.
by reflexivity.
split.
move => x y <- <-.
rewrite subr0.
by reflexivity.
rewrite /=.
move => x y <-.
rewrite mul0r.
by reflexivity.
*)qed.

(*The whole ring ideal is an ideal*)
lemma ringIdIsId : ideal ringId by done.

(*The intersection of two ideals is an ideal*)
lemma interIdIsId : forall i j , ideal i => ideal j => ideal (interId i j).
move => i j idi idj.
split.
exists zeror.
split.
by apply zeroInId.
by apply zeroInId.
split.
move => x y interx intery.
split.
apply substStabId.
by exact idi.
by case : interx.
by case : intery.
apply substStabId.
by exact idj.
by case : interx.
by case : intery.
move => x y interx.
split.
apply multStabId.
by exact idi.
by case : interx.
apply multStabId.
by exact idj.
by case : interx.
qed.

(*The sum of two ideals is an ideal*)
lemma sumIsId : forall i j , ideal i => ideal j => ideal (sumId i j).
move => i j idi idj.
split.
exists zeror zeror zeror.
split.
by rewrite addr0.
split.
by apply zeroInId.
by apply zeroInId.
split.
move => x y sumx sumy.
case : sumx.
move => x1 x2 [eqx [ix1 jx2]].
case : sumy.
move => y1 y2 [eqy [iy1 jy2]].
rewrite eqx eqy.
rewrite opprD.
exists (x1 - y1) (x2 - y2).
split.
ring.
split.
apply substStabId.
by exact idi.
by exact ix1.
by exact iy1.
apply substStabId.
by exact idj.
by exact jx2.
by exact jy2.
move => x y sumx.
case : sumx.
move => x1 x2 [eqx [ix1 jx2]].
rewrite eqx.
rewrite mulrDl.
exists (x1 * y) (x2 * y).
split.
by reflexivity.
split.
apply multStabId.
by exact idi.
by exact ix1.
apply multStabId.
by exact idj.
by exact jx2.
qed.

(*The quotient of two ideals is an ideal*)
lemma quoIdIsId : forall i j , ideal i => ideal j => ideal (quoId i j).
move => i j idi idj.
split.
exists zeror.
move => x jx.
rewrite mul0r.
by apply zeroInId.
split.
move => x y quox quoy z jz.
rewrite mulrDl mulNr.
apply substStabId.
by exact idi.
apply quox.
by exact jz.
apply quoy.
by exact jz.
move => x y quox z jz.
rewrite - mulrA.
apply quox.
rewrite mulrC.
apply multStabId.
by exact idj.
by exact jz.
qed.

(*The ideal generated by a non-empty subset of a ring is an ideal*)
lemma genNonEmptyIsId : forall i , (exists x , i x) => ideal (genId i).
move => i iNotEmpty.
apply : idealP.
+ case : iNotEmpty.
  move => x ix.
  exists x [(x,oner)].
  split.
  (*These two should just be a computation*)
  - by smt.
  - by smt.
+ move => x y genx geny.
  case : genx.
  move => lx [xEqBigSumlx unzip1Inilx].
  case : geny.
  move => ly [yEqBigSumly unzip1Inily].
  (*I want to multiply by -1 all the second elements of ly, and then concatenate lx and ly.*)
  by admit.
+ move => x y genx.
  case : genx.
  move => lx [xEqBigSumlx unzip1Inilx].
  (*I want to multiply by y all the second elements of lx.*)
  by admit.
qed.

(*The ideal generated by a set contains this set*)
lemma genIdContainsSet : forall i , forall x , i x => genId i x.
move => i x ix.
exists [(x,oner)].
split.
(*These two should just be a computation*)
+ by smt.
+ by smt.
qed.

(*The ideal generated by a set is the smallest ideal containing this set*)
lemma genIdSmallestIdContainingSet : forall i j , ideal j => (forall x , i x => j x) => (forall x , genId i x => j x).
move => i j idj iIncj x genx.
case : genx.
move => lx [xEqBigSumlx unzip1Inilx].
by admit.
qed.

(*The product of two ideals is an ideal*)
lemma prodIdIsId : forall i j , ideal i => ideal j => ideal (prodId i j).
move => i j idi idj.
apply genNonEmptyIsId.
exists zeror zeror zeror.
split.
by rewrite mul0r.
split.
by apply zeroInId.
by apply zeroInId.
qed.

(*The radical of an ideal is an ideal*)
lemma radIdIsId : forall i , ideal i => ideal (radId i).
move => i idi.
apply : idealP.
+ case : (existsxInId i idi).
  move => x ix.
  exists x 1.
  split.
  - by trivial.
  - by rewrite expr1.
+ move => x y radx rady.
  case : radx.
  move => nx [posnx inx].
  case : rady.
  move => ny [posny iny].
  exists (nx + ny).
  split.
  - by rewrite addz_ge0.
  - by admit.
+ move => x y radx.
  case : radx.
  move => nx [posnx inx].
  exists nx.
  split.
  - by exact posnx.
  - (*I would like to use something like expfM, but it seems to be only defined for fields*)
    by admit.
qed.

(*A principal ideal is an ideal*)
lemma principalIdIsId : forall i , principal i => ideal i.
move => i prini.
case : prini.
move => x eqi.
rewrite eqi.
apply genNonEmptyIsId.
by exists x.
qed.

(*A finitely generated ideal is an ideal*)
lemma finitelyGeneratedIdIsId : forall i , finitelyGenerated i => ideal i.
move => i fini.
case : fini.
move => lx [sizelx eqi].
rewrite eqi.
apply genNonEmptyIsId.
exists (head zeror lx).
(*I can't show that lx is of the form x::l*)
by admit.
qed.

(*A principal ideal is finitely generated*)
lemma principalIsFinitelyGenerated : forall i , principal i => finitelyGenerated i.
move => i prini.
case : prini.
move => x eqi.
exists [x].
split.
+ by trivial.
+ by admit.
qed.


(*How could I define quotients of rings?*)
(*All the non-explained admit are issues with lists.*)
