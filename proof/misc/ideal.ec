(**************************)
(**************************)
(**        Ideals        **)
(**************************)
(**************************)





(**************************)
(* Requirements           *)
(**************************)

require import AllCore Ring.

clone include ComRing.



(**************************)
(* Operators              *)
(**************************)

(*Ideal*)
op ideal (i : t -> bool) : bool =
   (exists x : t , i x)
/\ (forall x y : t , i x => i y => i (x-y))
/\ (forall x y : t , i x => i (x * y)).

(*The zero ideal*)
op zeroId : t -> bool =
(=) zeror.

(*The whole ring ideal*)
op ringId : t -> bool =
fun x => true.

(*Intersection of two ideals*)
op interId ( i j : t -> bool ) : t -> bool =
fun x => i x /\ j x.

(*Sum of two ideals*)
op sumId ( i j : t -> bool ) : t -> bool =
fun z => exists x y , (z = x + y) /\ i x /\ j y.

(*Quotient of two ideals*)
op quoId ( i j : t -> bool ) : t -> bool =
fun x => (forall y , j y => i (x * y)).

(*Ideal generated by a subset*)
op genId ( i : t-> bool ) : t -> bool.

(*Product of two ideals*)
op prodId ( i j : t -> bool ) : t -> bool =
genId (fun z => exists x y , (z = x * y) /\ i x /\ j y).



(**************************)
(* Lemmas                 *)
(**************************)


(*zeror is in any ideal*)
lemma zeroInId : forall i , ideal i => i zeror.
move => i [existsxInId [substStabId multStabId]].
case existsxInId.
move => x xIni.
rewrite - (subrr x).
rewrite (substStabId x x).
by exact xIni.
by exact xIni.
qed.

(*Ideals are not empty*)
lemma existsxInId : forall i , ideal i => exists x , i x.
move => i [existsxInId [substStabId multStabId]].
by exact existsxInId.
qed.

(*Ideals are stable by substraction*)
lemma substStabId : forall i , ideal i => forall x y  , i x => i y => i (x-y).
move => i [existsxInId [substStabId multStabId]].
by exact substStabId.
qed.

(*Ideals are stable by multiplication by an element of the ring*)
lemma multStabId : forall i , ideal i => forall x y  , i x => i (x * y).
move => i [existsxInId [substStabId multStabId]].
by exact multStabId.
qed.

(*The zero ideal is an ideal*)
(*This proof would be more elegant if I could split in three the conjunction immediatly.*)
lemma zeroIdIsId : ideal zeroId.
split.
exists zeror.
by reflexivity.
split.
move => x y <- <-.
rewrite subr0.
by reflexivity.
rewrite /=.
move => x y <-.
rewrite mul0r.
by reflexivity.
qed.

(*The whole ring ideal is an ideal*)
lemma ringIdIsId : ideal ringId by done.

(*The intersection of two ideals is an ideal*)
lemma iterIdIsId : forall i j , ideal i => ideal j => ideal (interId i j).
move => i j idi idj.
split.
exists zeror.
split.
by apply zeroInId.
by apply zeroInId.
split.
move => x y interx intery.
split.
apply substStabId.
by exact idi.
by case : interx.
by case : intery.
apply substStabId.
by exact idj.
by case : interx.
by case : intery.
move => x y interx.
split.
apply multStabId.
by exact idi.
by case : interx.
apply multStabId.
by exact idj.
by case : interx.
qed.

(*The sum of two ideals is an ideal*)
lemma sumIsId : forall i j , ideal i => ideal j => ideal (sumId i j).
move => i j idi idj.
split.
exists zeror zeror zeror.
split.
by rewrite addr0.
split.
by apply zeroInId.
by apply zeroInId.
split.
move => x y sumx sumy.
case : sumx.
move => x1 x2 [eqx [ix1 jx2]].
case : sumy.
move => y1 y2 [eqy [iy1 jy2]].
rewrite eqx eqy.
rewrite opprD.
exists (x1 - y1) (x2 - y2).
split.
(*ring does not work here?*)
(*Use of many associativity and commutativity lemmas, will manage eventually*)
(*admit.*)
split.
apply substStabId.
by exact idi.
by exact ix1.
by exact iy1.
apply substStabId.
by exact idj.
by exact jx2.
by exact jy2.
move => x y sumx.
case : sumx.
move => x1 x2 [eqx [ix1 jx2]].
rewrite eqx.
rewrite mulrDl.
exists (x1 * y) (x2 * y).
split.
by reflexivity.
split.
apply multStabId.
by exact idi.
by exact ix1.
apply multStabId.
by exact idj.
by exact jx2.
qed.

(*The quotient of two ideals is an ideal*)
lemma quoIdIsId : forall i j , ideal i => ideal j => ideal (quoId i j).
move => i j idi idj.
split.
exists zeror.
move => x jx.
rewrite mul0r.
by apply zeroInId.
split.
move => x y quox quoy z jz.
rewrite mulrDl mulNr.
apply substStabId.
by exact idi.
apply quox.
by exact jz.
apply quoy.
by exact jz.
move => x y quox z jz.
rewrite - mulrA.
apply quox.
rewrite mulrC.
apply multStabId.
by exact idj.
by exact jz.
qed.

(*The ideal generated by a non-empty subset of a ring is an ideal*)
lemma genNonEmptyIsId : forall i , (exists x , i x) => ideal (genId i). admitted.

(*The product of two ideals is an ideal*)
lemma prodIdIsId : forall i j , ideal i => ideal j => ideal (prodId i j).
move => i j idi idj.
apply genNonEmptyIsId.
exists zeror zeror zeror.
split.
by rewrite mul0r.
split.
by apply zeroInId.
by apply zeroInId.
qed.




(*idéal généré par une sous-partie, idéal de type fini, principal, radical d'un idéal.*)

