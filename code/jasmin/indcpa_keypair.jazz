#include "params.jahh"
#include "poly_compress.jahh"
#include "poly_decompress.jahh"
#include "poly_tobytes.jahh"
#include "poly_frombytes.jahh"
#include "poly_tomsg.jahh"
#include "poly_frommsg.jahh"
#include "poly_add.jahh"
#include "poly_ntt.jahh"
#include "poly_invntt.jahh"
#include "poly_basemul.jahh"
#include "poly_frommont.jahh"
#include "poly_reduce.jahh"
#include "poly_csubq.jahh"
#include "poly_getnoise.jahh"
#include "polyvec_tobytes.jahh"
#include "polyvec_add.jahh"
#include "polyvec_pointwise_acc.jahh"
#include "polyvec_ntt.jahh"
#include "polyvec_csubq.jahh"
#include "polyvec_reduce.jahh"
#include "gen_matrix.jahh"


export fn indcpa_keypair_jazz(reg u64 pkp, reg u64 skp, reg u64 randomnessp, reg u64 zetasp)
{
  stack u16[KYBER_VECN] a0 a1 a2 e pkpv skpv;
  stack u16[KYBER_N] poly;
  stack u8[64] buf;
  stack u8[KYBER_SYMBYTES] publicseed noiseseed;
  stack u8[32] inbuf;
  reg u16 t;
  reg u8 c;
  reg u64 zero;
  reg u8 nonce;
  reg u64 i, j;

  i = 0;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[randomnessp + i];
    inbuf[(int) i] = c;
    i += 1;
  }


  buf = sha3512_32(inbuf);

  i = 0;
  j = KYBER_SYMBYTES;
  while (i < KYBER_SYMBYTES)
  {
    c = buf[(int)i];
    publicseed[(int)i] = c;
    c = buf[(int)j];
    noiseseed[(int)i] = c;
    i += 1;
    j += 1;
  }

  zero = 0; 
  a0, a1, a2 = gen_matrix(publicseed, zero);

  nonce = 0;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    skpv[(int)i] = t;
    i += 1;
  }

  nonce += 1;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    skpv[(int)j] = t;
    i += 1;
    j += 1;
  }

  nonce += 1;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = 2*KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    skpv[(int)j] = t;
    i += 1;
    j += 1;
  }

  nonce += 1;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    e[(int)i] = t;
    i += 1;
  }

  nonce += 1;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    e[(int)j] = t;
    i += 1;
    j += 1;
  }

  nonce += 1;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = 2*KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    e[(int)j] = t;
    i += 1;
    j += 1;
  }


  skpv = polyvec_ntt(skpv, zetasp);
  e = polyvec_ntt(e, zetasp);

  poly = polyvec_pointwise_acc(a0, skpv, zetasp);
  poly = poly_frommont(poly);
  i = 0;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    pkpv[(int)i] = t;
    i += 1;
  }

  poly = polyvec_pointwise_acc(a1, skpv, zetasp);
  poly = poly_frommont(poly);
  i = 0;
  j = KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    pkpv[(int)j] = t;
    i += 1;
    j += 1;
  }

  poly = polyvec_pointwise_acc(a2, skpv, zetasp);
  poly = poly_frommont(poly);
  i = 0;
  j = 2*KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    pkpv[(int)j] = t;
    i += 1;
    j += 1;
  }


  pkpv = polyvec_add(pkpv, e);
  pkpv = polyvec_reduce(pkpv);

  polyvec_tobytes(skp, skpv);
  polyvec_tobytes(pkp, pkpv);

  i = 0;
  pkp += KYBER_POLYVECBYTES; 
  while (i < KYBER_SYMBYTES)
  {
    c = publicseed[(int)i];
    (u8)[pkp] = c;
    pkp += 1;
  }
}
