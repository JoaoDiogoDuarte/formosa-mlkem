require "params.jinc"
require "consts.jinc"
require "shuffle.jinc"
require "poly_csubq.jinc"

fn _poly_tobytes(reg u64 rp, reg ptr u16[KYBER_N] a) -> reg ptr u16[KYBER_N]
{
  inline int i;
  reg u256 t0 t1 t2 t3 t4 t5 t6 t7 qx16 tt ttt;
  reg ptr u16[16] jqx16_p;

  jqx16_p = jqx16;
  qx16 = jqx16_p[u256 0];

  for i = 0 to 2
  {
    t0 = a[u256 8*i];
    t1 = a[u256 8*i + 1];
    t2 = a[u256 8*i + 2];
    t3 = a[u256 8*i + 3];
    t4 = a[u256 8*i + 4];
    t5 = a[u256 8*i + 5];
    t6 = a[u256 8*i + 6];
    t7 = a[u256 8*i + 7];

    t0 = __csubq(t0, qx16);
    t1 = __csubq(t1, qx16);
    t2 = __csubq(t2, qx16);
    t3 = __csubq(t3, qx16);
    t4 = __csubq(t4, qx16);
    t5 = __csubq(t5, qx16);
    t6 = __csubq(t6, qx16);
    t7 = __csubq(t7, qx16);

    tt = #VPSLL_16u16(t1, 12);
    tt |= t0;

    t0 = #VPSRL_16u16(t1, 4);
    t1 = #VPSLL_16u16(t2, 8);
    t0 |= t1;

    t1 = #VPSRL_16u16(t2, 8);
    t2 = #VPSLL_16u16(t3, 4);
    t1 |= t2;

    t2 = #VPSLL_16u16(t5, 12);
    t2 |= t4;

    t3 = #VPSRL_16u16(t5, 4);
    t4 = #VPSLL_16u16(t6, 8);
    t3 |= t4;

    t4 = #VPSRL_16u16(t6, 8);
    t5 = #VPSLL_16u16(t7, 4);
    t4 |= t5;

    ttt, t0 = __shuffle1(tt, t0);
    tt, t2 = __shuffle1(t1, t2);
    t1, t4 = __shuffle1(t3, t4);

    t3, tt= __shuffle2(ttt, tt);
    ttt, t0 = __shuffle2(t1, t0);
    t1, t4 = __shuffle2(t2, t4);

    t2, ttt = __shuffle4(t3, ttt);
    t3, tt = __shuffle4(t1, tt);
    t1, t4 = __shuffle4(t0, t4);

    t0, t3 = __shuffle8(t2, t3);
    t2, ttt = __shuffle8(t1, ttt);
    t1, t4 = __shuffle8(tt, t4);

    (u256)[rp + 192*i] = t0;
    (u256)[rp + 192*i + 32] = t2;
    (u256)[rp + 192*i + 64] = t1;
    (u256)[rp + 192*i + 96] = t3;
    (u256)[rp + 192*i + 128] = ttt;
    (u256)[rp + 192*i + 160] = t4;
  }

  return a;
}
