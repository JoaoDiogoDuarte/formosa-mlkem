#ifndef GEN_MATRIX_HH
#define GEN_MATRIX_HH

#include "fips202.jahh"
#include "fips202_4x.jahh"
#include "params.jahh"
#include "shuffle.jahh"

param int GENMATRIX_NBLOCKS = 6;

inline
fn shake128_squeezenblocks(stack u64[25] state, stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] out) 
      -> stack u64[25], stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE]
{
  inline int i;

  for i = 0 to GENMATRIX_NBLOCKS 
  {
      state, out[i*SHAKE128_RATE:SHAKE128_RATE] = shake128_squeezeblock(state, out[i*SHAKE128_RATE:SHAKE128_RATE]);
  }
  return state, out;
}


inline
fn shake128_squeezenblocks4x(reg ptr u256[25] state,
                              reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] h0,
                              reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] h1,
                              reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] h2,
                              reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] h3)
  -> reg ptr u256[25], reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE], reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE], reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE], reg ptr u8[GENMATRIX_NBLOCKS*SHAKE128_RATE]
{
  inline int i;

  for i = 0 to GENMATRIX_NBLOCKS
  {
    state, h0[i*SHAKE128_RATE:SHAKE128_RATE], h1[i*SHAKE128_RATE:SHAKE128_RATE], h2[i*SHAKE128_RATE:SHAKE128_RATE], h3[i*SHAKE128_RATE:SHAKE128_RATE] = shake128_squeezeblock4x(state, h0[i*SHAKE128_RATE:SHAKE128_RATE], h1[i*SHAKE128_RATE:SHAKE128_RATE], h2[i*SHAKE128_RATE:SHAKE128_RATE], h3[i*SHAKE128_RATE:SHAKE128_RATE]);
  }

  return state, h0, h1, h2, h3;
}


inline
fn rej_uniform(stack u16[KYBER_N] rp, reg u64 offset, stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf, inline int buflen) ->  reg u64, stack u16[KYBER_N]
{
  reg u16 val1 val2;
  reg u16 t;
  reg u64 pos ctr;
  reg u64 cnd0 cnd1 exit;


  ctr = offset;
  pos = 0;
  exit = 0;

  while(exit == 0)
  {
    val1 = (16u)buf[(int)pos];
    pos += 1;

    t   = (16u)buf[(int)pos];
    val2 = t;
    val2 >>= 4;

    t &= 0x0F;
    t <<= 8;
    val1 |= t;
    pos += 1;

    t   = (16u)buf[(int)pos];
    t <<= 4;
    val2 |= t;
    pos += 1;

    if(val1 < KYBER_Q)
    {
      rp[(int)ctr] = val1;
      ctr += 1;
    }

    if(val2 < KYBER_Q)
    {
      if(ctr < KYBER_N)
      {
        rp[(int)ctr] = val2;
        ctr += 1;
      }
    }

    // Check if we should exit the loop
    cnd0  = KYBER_N;
    cnd0 -= ctr;
    cnd0 -= 1;
    cnd1  = buflen;
    cnd1 -= pos;
    cnd1 -= 3;
    exit  = cnd0 | cnd1;
    exit >>= 63;
  }

  return ctr, rp;
}

inline
fn gen_matrix_old(stack u8[KYBER_SYMBYTES] seed, inline int transposed) -> stack u16[KYBER_K*KYBER_VECN]
{
  stack u8[34] extseed;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf;
  stack u64[25] state;
  stack u16[KYBER_K*KYBER_VECN] rr;

  reg u8 c;
  reg u16 t;
  reg u64 ctr k l;
  stack u64 sctr;
  inline int i, j, k;

  for j = 0 to KYBER_SYMBYTES
  {
    c = seed[j];
    extseed[j] = c;
  }

  for i = 0 to KYBER_K
  {
    for j = 0 to KYBER_K
    {
      if(transposed == 0)
      {
        extseed[KYBER_SYMBYTES] = j;
        extseed[KYBER_SYMBYTES+1] = i;
      }
      else
      {
        extseed[KYBER_SYMBYTES] = i;
        extseed[KYBER_SYMBYTES+1] = j;
      }

      state = shake128_absorb34(state, extseed);

      state, buf = shake128_squeezenblocks(state, buf);
      ctr = 0;
      ctr, rr[i*KYBER_VECN+j*KYBER_N:KYBER_N] = rej_uniform(rr[i*KYBER_VECN+j*KYBER_N:KYBER_N], ctr, buf, GENMATRIX_NBLOCKS*SHAKE128_RATE);
      
      while (ctr < KYBER_N)
      {
        state, buf[0:SHAKE128_RATE] = shake128_squeezeblock(state, buf[0:SHAKE128_RATE]);
        ctr, rr[i*KYBER_VECN+j*KYBER_N:KYBER_N] = rej_uniform(rr[i*KYBER_VECN+j*KYBER_N:KYBER_N], ctr, buf, SHAKE128_RATE);
      }
      rr[i*KYBER_VECN+j*KYBER_N:KYBER_N] = nttunpack(rr[i*KYBER_VECN+j*KYBER_N:KYBER_N]);
    }
  }

  return rr;
}

inline
fn gen_matrix(stack u8[KYBER_SYMBYTES] seed, inline int transposed) -> stack u16[KYBER_K*KYBER_VECN]
{
  stack u8[34] extseed0;
  stack u8[34] extseed1;
  stack u8[34] extseed2;
  stack u8[34] extseed3;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf0;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf1;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf2;
  stack u8[GENMATRIX_NBLOCKS*SHAKE128_RATE] buf3;
  stack u256[25] state;
  stack u16[KYBER_K*KYBER_VECN] rr;

  reg u8 c;
  reg u16 t;
  reg u64 ctr0 ctr1 ctr2 ctr3 k l;
  inline int i, j, k;

  for j = 0 to KYBER_SYMBYTES
  {
    c = seed[j];
    extseed0[j] = c;
    extseed1[j] = c;
    extseed2[j] = c;
    extseed3[j] = c;
  }

  if(transposed == 1)
  {
    extseed0[KYBER_SYMBYTES]   = 0;
    extseed0[KYBER_SYMBYTES+1] = 0;
    extseed1[KYBER_SYMBYTES]   = 0;
    extseed1[KYBER_SYMBYTES+1] = 1;
    extseed2[KYBER_SYMBYTES]   = 0;
    extseed2[KYBER_SYMBYTES+1] = 2;
    extseed3[KYBER_SYMBYTES]   = 1;
    extseed3[KYBER_SYMBYTES+1] = 0;
  }
  else
  {
    extseed0[KYBER_SYMBYTES]   = 0;
    extseed0[KYBER_SYMBYTES+1] = 0;
    extseed1[KYBER_SYMBYTES]   = 1;
    extseed1[KYBER_SYMBYTES+1] = 0;
    extseed2[KYBER_SYMBYTES]   = 2;
    extseed2[KYBER_SYMBYTES+1] = 0;
    extseed3[KYBER_SYMBYTES]   = 0;
    extseed3[KYBER_SYMBYTES+1] = 1;
  }

  state = shake128_absorb4x_34(state, extseed0, extseed1, extseed2, extseed3);

  state, buf0, buf1, buf2, buf3 = shake128_squeezenblocks4x(state, buf0, buf1, buf2, buf3);

  ctr0 = 0;
  ctr1 = 0;
  ctr2 = 0;
  ctr3 = 0;

  ctr0, rr[0*KYBER_VECN+0*KYBER_N:KYBER_N] = rej_uniform(rr[0*KYBER_VECN+0*KYBER_N:KYBER_N], ctr0, buf0, GENMATRIX_NBLOCKS*SHAKE128_RATE);
  ctr1, rr[0*KYBER_VECN+1*KYBER_N:KYBER_N] = rej_uniform(rr[0*KYBER_VECN+1*KYBER_N:KYBER_N], ctr1, buf1, GENMATRIX_NBLOCKS*SHAKE128_RATE);
  ctr2, rr[0*KYBER_VECN+2*KYBER_N:KYBER_N] = rej_uniform(rr[0*KYBER_VECN+2*KYBER_N:KYBER_N], ctr2, buf2, GENMATRIX_NBLOCKS*SHAKE128_RATE);
  ctr3, rr[1*KYBER_VECN+0*KYBER_N:KYBER_N] = rej_uniform(rr[1*KYBER_VECN+0*KYBER_N:KYBER_N], ctr3, buf3, GENMATRIX_NBLOCKS*SHAKE128_RATE);

  //TODO: Check if enough has been generated; squeeze more

  if(transposed == 1)
  {
    extseed0[KYBER_SYMBYTES]   = 1;
    extseed0[KYBER_SYMBYTES+1] = 1;
    extseed1[KYBER_SYMBYTES]   = 1;
    extseed1[KYBER_SYMBYTES+1] = 2;
    extseed2[KYBER_SYMBYTES]   = 2;
    extseed2[KYBER_SYMBYTES+1] = 0;
    extseed3[KYBER_SYMBYTES]   = 2;
    extseed3[KYBER_SYMBYTES+1] = 1;
  }
  else
  {
    extseed0[KYBER_SYMBYTES]   = 1;
    extseed0[KYBER_SYMBYTES+1] = 1;
    extseed1[KYBER_SYMBYTES]   = 2;
    extseed1[KYBER_SYMBYTES+1] = 1;
    extseed2[KYBER_SYMBYTES]   = 0;
    extseed2[KYBER_SYMBYTES+1] = 2;
    extseed3[KYBER_SYMBYTES]   = 1;
    extseed3[KYBER_SYMBYTES+1] = 2;
  }

  state = shake128_absorb4x_34(state, extseed0, extseed1, extseed2, extseed3);

  state, buf0, buf1, buf2, buf3 = shake128_squeezenblocks4x(state, buf0, buf1, buf2, buf3);

  ctr0 = 0;
  ctr1 = 0;
  ctr2 = 0;
  ctr3 = 0;

  ctr0, rr[1*KYBER_VECN+1*KYBER_N:KYBER_N] = rej_uniform(rr[1*KYBER_VECN+1*KYBER_N:KYBER_N], ctr0, buf0, GENMATRIX_NBLOCKS*SHAKE128_RATE);
  ctr1, rr[1*KYBER_VECN+2*KYBER_N:KYBER_N] = rej_uniform(rr[1*KYBER_VECN+2*KYBER_N:KYBER_N], ctr1, buf1, GENMATRIX_NBLOCKS*SHAKE128_RATE);
  ctr2, rr[2*KYBER_VECN+0*KYBER_N:KYBER_N] = rej_uniform(rr[2*KYBER_VECN+0*KYBER_N:KYBER_N], ctr2, buf2, GENMATRIX_NBLOCKS*SHAKE128_RATE);
  ctr3, rr[2*KYBER_VECN+1*KYBER_N:KYBER_N] = rej_uniform(rr[2*KYBER_VECN+1*KYBER_N:KYBER_N], ctr3, buf3, GENMATRIX_NBLOCKS*SHAKE128_RATE);

  //TODO: Check if enough has been generated; squeeze more

  extseed0[KYBER_SYMBYTES]   = 2;
  extseed0[KYBER_SYMBYTES+1] = 2;
  
  state[u64 0:25] = shake128_absorb34(state[u64 0:25], extseed0);
  
  state[u64 0:25], buf0 = shake128_squeezenblocks(state[u64 0:25], buf0);
  
  ctr0 = 0;
  ctr0, rr[2*KYBER_VECN+2*KYBER_N:KYBER_N] = rej_uniform(rr[2*KYBER_VECN+2*KYBER_N:KYBER_N], ctr0, buf0, GENMATRIX_NBLOCKS*SHAKE128_RATE);
  
  //TODO: Check if enough has been generated; squeeze more

  for i = 0 to KYBER_K
  {
    for j = 0 to KYBER_K
    {
      rr[i*KYBER_VECN+j*KYBER_N:KYBER_N] = nttunpack(rr[i*KYBER_VECN+j*KYBER_N:KYBER_N]);
    }
  }

  return rr;
}

#endif
