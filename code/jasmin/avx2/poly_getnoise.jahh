#ifndef POLY_GETNOISE_HH
#define POLY_GETNOISE_HH

#include "params.jahh"
#include "fips202.jahh"

fn poly_getnoise(reg ptr u16[KYBER_N] rp, reg ptr u8[KYBER_SYMBYTES] seed, reg u8 nonce) -> reg ptr u16[KYBER_N]
{
  stack u8[33] extseed;   /* 33 = KYBER_SYMBYTES +1 */
  stack u8[128] buf;      /* 128 = KYBER_ETA*KYBER_N/4 */
  reg u64 outlen;
  reg u8 c,a,b;
  reg u16 t;
  reg u64 i j;
  inline int k;

  stack ptr u16[KYBER_N] srp;

  srp = rp;
  
  for k = 0 to KYBER_SYMBYTES
  {
    c = seed[k];
    extseed[k] = c;
  }
  extseed[KYBER_SYMBYTES] = nonce;

  buf = shake256_128_33(buf, extseed);

  rp = srp;
  
  i = 0;
  j = 0;
  while (i < 128) {
    c = buf[(int)i];
    a = c;
    a &= 0x55;

    c >>= 1;
    c &= 0x55;
    c += a;

    a = c;
    a &= 0x3;
    b = c;
    b >>= 2;
    b &= 0x3;
    a -= b;
    t = (16s)a;
    rp[(int)j] = t;
    a = c;
    a >>= 4;
    a &= 0x3;
    b = c >> 6;
    b &= 0x3;
    a -= b;
    t = (16s)a;
    j += 1;
    rp[(int)j] = t;
    i += 1;
    j += 1;
  }
  
  return rp;
}


fn poly_getnoise_avx(reg ptr u16[KYBER_N] rp, reg ptr u8[KYBER_SYMBYTES] seed, reg u8 nonce) -> reg ptr u16[KYBER_N]
{
  inline int i;
  reg u256 f0 f1 f2 f3;
  reg u128 t;
  reg u256 mask55 mask33 mask03 mask0F;
  reg u64 t64;
  stack ptr u16[KYBER_N] srp;
  stack u8[128] buf;
  stack u8[33] extseed;
  stack u32 mask55_s mask33_s mask03_s mask0F_s;

  mask55_s = 0x55555555;
  mask33_s = 0x33333333;
  mask03_s = 0x03030303;
  mask0F_s = 0x0F0F0F0F;

  srp = rp;

  for i=0 to KYBER_SYMBYTES/8
  {
    t64 = seed[u64 i];
    extseed[u64 i] = t64;
  }
  extseed[KYBER_SYMBYTES] = nonce;

  buf = shake256_128_33(buf, extseed);

  rp = srp;

  mask55 = #VPBROADCAST_8u32(mask55_s);
  mask33 = #VPBROADCAST_8u32(mask33_s);
  mask03 = #VPBROADCAST_8u32(mask03_s);
  mask0F = #VPBROADCAST_8u32(mask0F_s);

  for i=0 to KYBER_N/64
  {
    f0 = buf[u256 i];

    f1 = #VPSRL_16u16(f0, 1);
    f0 = #VPAND_256(mask55, f0);
    f1 = #VPAND_256(mask55, f1);
    f0 = #VPADD_32u8(f0, f1);

    f1 = #VPSRL_16u16(f0, 2);
    f0 = #VPAND_256(mask33, f0);
    f1 = #VPAND_256(mask33, f1);
    f0 = #VPADD_32u8(f0, mask33);
    f0 = #VPSUB_32u8(f0, f1);

    f1 = #VPSRL_16u16(f0, 4);
    f0 = #VPAND_256(mask0F, f0);
    f1 = #VPAND_256(mask0F, f1);
    f0 = #VPSUB_32u8(f0, mask03);
    f1 = #VPSUB_32u8(f1, mask03);

    f2 = #VPUNPCKL_32u8(f0, f1);
    f3 = #VPUNPCKH_32u8(f0, f1);

    t = (128u)f2;
    f0 = #VPMOVSX_16u8_16u16(t);
    t = #VEXTRACTI128(f2, 1);
    f1 = #VPMOVSX_16u8_16u16(t);
    t = (128u)f3;
    f2 = #VPMOVSX_16u8_16u16(t);
    t = #VEXTRACTI128(f3, 1);
    f3 = #VPMOVSX_16u8_16u16(t);
    rp[u256 4*i] = f0;
    rp[u256 4*i + 1] = f2;
    rp[u256 4*i + 2] = f1;
    rp[u256 4*i + 3] = f3;
  }

  return rp;
}

#endif
