#ifndef POLY_FROMMSG_HH
#define POLY_FROMMSG_HH

#include "params.jahh"

fn poly_frommsg(reg ptr u16[KYBER_N] rp, reg u64 ap) -> stack u16[KYBER_N]
{
  reg u8 c;
  reg u16 t;
  inline int i;
  inline int j;

  for i = 0 to 32
  {
    c = (u8)[ap + i];

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+1] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+2] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+3] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+4] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+5] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+6] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+7] = t;
    c >>= 1;
  }
  return rp;
}

u16[16] shift_s = {0, 1, 2, 3, 4, 5, 6, 7,
                  8, 9, 10, 11, 12, 13, 14, 15};
u16 mask_s = 0x0001;

fn poly_frommsg_avx(reg ptr u16[KYBER_N] rp, reg u64 ap) -> stack u16[KYBER_N]
{
  inline int i;
  reg u256 t0 hq shift mask;
  reg u16 c;
  reg ptr u16[16] hqp;

  hqp = hqx16;
  hq = hqp[u256 0];

  mask = #VPBROADCAST_16u16(mask_s);
  shift = shift_s[u256 0];

  for i=0 to 16
  {
    t0 = #VPBROADCAST_16u16((u16)[ap+2*i]);
    t0 = #VPSRLV_16u16(t0, shift);
    t0 = #VPAND_256(t0, mask);
    t0 = #VPMULL_16u16(t0, hq);
    rp[u256 i] = t0;
  }
  return rp;
}

#endif
