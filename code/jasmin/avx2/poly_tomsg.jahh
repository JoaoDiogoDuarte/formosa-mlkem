#ifndef POLY_TOMSG_HH
#define POLY_TOMSG_HH

#include "params.jahh"
#include "consts.jahh"
#include "poly_csubq.jahh"

fn poly_tomsg(reg u64 rp, reg ptr u16[KYBER_N] a) -> reg ptr u16[KYBER_N]
{
  reg u16 t;
  reg u8 r;
  reg u32 d;
  inline int i j k;
  
  a = poly_csubq(a); 

  for i = 0 to 32
  {
    r = 0;
    for j = 0 to 8
    {
      t = a[8*i+j]; 
      d = (32u)t;
      d <<= 1;
      d += 1665;
      d *= 80635;
      d >>= 28;
      d &= 1;
      d <<= j;
      r  |= d;
    }

    (u8)[rp+i] = r;
  }
  return a;
}

fn poly_tomsg_avx(reg u64 rp, reg ptr u16[KYBER_N] a) -> reg ptr u16[KYBER_N]
{
  inline int i;
  reg u256 f0 f1 g0 g1 hq hhq;
  reg ptr u16[16] px16;
  reg u32 c;

  a = poly_csubq(a);

  px16 = hqx16_m1;
  hq = px16[u256 0];

  px16 = hhqx16;
  hhq = px16[u256 0];

  for i=0 to KYBER_N/32
  {
    f0 = a[u256 2*i];
    f1 = a[u256 2*i + 1];
    f0 = #VPSUB_16u16(hq, f0);
    f1 = #VPSUB_16u16(hq, f1);
    g0 = #VPSRA_16u16(f0, 15);
    g1 = #VPSRA_16u16(f1, 15);
    f0 = #VPXOR_256(f0, g0);
    f1 = #VPXOR_256(f1, g1);
    f0 = #VPSUB_16u16(f0, hhq);
    f1 = #VPSUB_16u16(f1, hhq);
    f0 = #VPACKSS_16u16(f0, f1);
    f0 = #VPERMQ(f0, 0xD8);
    c = #VPMOVMSKB_u256u32(f0);
    (u32)[rp+4*i] = c;
  }
  return a;
}

#endif
