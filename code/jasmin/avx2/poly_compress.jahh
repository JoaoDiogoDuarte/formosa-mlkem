#ifndef POLY_COMPRESS_HH
#define POLY_COMPRESS_HH

#include "params.jahh"
#include "poly_csubq.jahh"

fn poly_compress(reg u64 rp, reg ptr u16[KYBER_N] a) -> reg ptr u16[KYBER_N]
{
  reg u16 t;
  reg u32 d0, d1;
  reg u64 i j;

  a = poly_csubq(a);

  i = 0;
  j = 0;
  while(i < 128)
  {
    t  = a[(int)j];
    d0 = (32u)t;
    d0 <<= 4;
    d0 += 1665;
    d0 *= 80635;
    d0 >>= 28;
    d0 &= 0xf;
    j += 1;
    t  = a[(int)j];
    d1 = (32u)t;
    d1 <<= 4;
    d1 += 1665;
    d1 *= 80635;
    d1 >>= 28;
    d1 &= 0xf;
    d1 <<= 4;
    d0 |= d1;
    (u8)[rp+i] = d0;
    i += 1;
    j += 1;
  }
  return a;
}


/*
  reg u256 x y t0 t1 r qx16 shuf;

  qx16 = jqx16[u256 0];
  shuf = jshuf[u256 0];

  for i = 0 to 16 {
    x  = a.[u256 32*i];

    x  = csubq(x, qx16);

    y  = #VPXOR_256(y, y);
    t0 = #VPUNPCKL_8u32(y, x);
    t1 = #VPUNPCKHW_8u32(y, x);

    // TODO

    t0 = #VPACKUS
  }


  .global unpck
unpck:

vmovdqu 0(%rsi), %ymm0
vmovdqu 0(%rdx), %ymm8
vpxor   %ymm1, %ymm1, %ymm1
vpunpcklwd %ymm1, %ymm0, %ymm2
vpunpckhwd %ymm1, %ymm0, %ymm3

// TODO:  do actual work
vpsrad $12,%ymm2,%ymm2
vpsrad $12,%ymm3,%ymm3



vpackusdw %ymm2, %ymm3, %ymm2
vpsrad $12, %ymm2, %ymm4
vpxor %ymm2, %ymm4, %ymm2

vpshufb %ymm8, %ymm2, %ymm2
vperm2f128 $21, %ymm2, %ymm2, %ymm3
vpxor %ymm2, %ymm3, %ymm2

vpextrq $0, %xmm2, 0(%rdi)

ret
*/


#endif
