#include "poly_compress.jahh"
#include "poly_decompress.jahh"
#include "poly_tobytes.jahh"
#include "poly_frombytes.jahh"
#include "poly_tomsg.jahh"
#include "poly_frommsg.jahh"
#include "poly_add2.jahh"
#include "poly_sub.jahh"
#include "poly_ntt.jahh"
#include "poly_invntt.jahh"
#include "poly_basemul.jahh"
#include "poly_frommont.jahh"
#include "poly_reduce.jahh"
#include "poly_csubq.jahh"
#include "poly_getnoise.jahh"
#include "polyvec_tobytes.jahh"
#include "polyvec_frombytes.jahh"
#include "polyvec_compress.jahh"
#include "polyvec_decompress.jahh"
#include "polyvec_add2.jahh"
#include "polyvec_pointwise_acc.jahh"
#include "polyvec_ntt.jahh"
#include "polyvec_invntt.jahh"
#include "polyvec_csubq.jahh"
#include "polyvec_reduce.jahh"
#include "gen_matrix.jahh"

/* Exported functions only for benchmarking */
export fn gen_matrix_jazz(reg u64 ap, reg u64 seedp)
{
  stack u16[KYBER_K*KYBER_VECN] aa;
  stack u8[KYBER_SYMBYTES] seed;

  aa = gen_matrix(seed, 1);
}

export fn poly_compress_jazz(reg u64 rp, reg u64 ap) 
{
  stack u16[KYBER_N] a;

  a = poly_compress_avx(rp, a);
}

export fn poly_decompress_jazz(reg u64 rp, reg u64 ap) 
{
  stack u16[KYBER_N] r;

  r = poly_decompress_avx(r, ap);
}

export fn poly_tomsg_jazz(reg u64 rp, reg u64 ap) 
{
  stack u16[KYBER_N] a;

  a = poly_tomsg_avx(rp, a);
}

export fn poly_frommsg_jazz(reg u64 rp, reg u64 ap) 
{
  stack u16[KYBER_N] r;

  r = poly_frommsg_avx(r, ap);
}

export fn poly_ntt_jazz(reg u64 rp) 
{
  stack u16[KYBER_N] r;

  r = poly_ntt(r);
}

export fn poly_invntt_jazz(reg u64 rp) 
{
  stack u16[KYBER_N] r;

  r = poly_invntt(r);
}


export fn poly_getnoise_jazz(reg u64 rp, reg u64 seedp, reg u8 nonce) 
{
  stack u16[KYBER_N] r;
  stack u8[KYBER_SYMBYTES] seed;

  r = poly_getnoise_avx(r, seed, nonce);
}


export fn poly_getnoise_4x_jazz(reg u64 r0 r1 r2 r3, reg u64 seedp, reg u8 nonce) 
{
  stack u16[KYBER_N] r0 r1 r2 r3;
  stack u8[KYBER_SYMBYTES] seed;

  r0, r1, r2, r3 = poly_getnoise_4x(r0, r1, r2, r3, seed, nonce);
}



export fn polyvec_decompress_jazz(reg u64 rp, reg u64 ap) 
{
  stack u16[KYBER_VECN] r;

  r = polyvec_decompress_avx(ap);
}


export fn polyvec_compress_jazz(reg u64 rp, reg u64 ap) 
{
  stack u16[KYBER_VECN] a;

  polyvec_compress_avx(rp, a);
}


export fn polyvec_pointwise_acc_jazz(reg u64 rp, reg u64 ap, reg u64 bp) 
{
  stack u16[KYBER_VECN] a;
  stack u16[KYBER_VECN] b;
  stack u16[KYBER_N] r;

  r = polyvec_pointwise_acc(r, a, b);
}


export fn indcpa_keypair_jazz(reg u64 pkp, reg u64 skp, reg u64 randomnessp)
{
  stack u16[KYBER_K*KYBER_VECN] aa;
  stack u16[KYBER_VECN] a0 a1 a2 e pkpv skpv;
  stack u16[KYBER_N] poly0 poly1 poly2;
  stack u8[64] buf;
  stack u8[KYBER_SYMBYTES] publicseed noiseseed;
  stack u8[32] inbuf;
  reg u8 c nonce;
  reg u64 i, j;

  stack u64 spkp;
  stack u64 sskp;

  spkp = pkp;
  sskp = skp;

  i = 0;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[randomnessp + i];
    inbuf[(int) i] = c;
    i += 1;
  }

  buf = sha3512_32(buf, inbuf);

  i = 0;
  j = KYBER_SYMBYTES;
  while (i < KYBER_SYMBYTES)
  {
    c = buf[(int)i];
    publicseed[(int)i] = c;
    c = buf[(int)j];
    noiseseed[(int)i] = c;
    i += 1;
    j += 1;
  }

  aa = gen_matrix(publicseed, 0);

  nonce = 0;
  skpv[0:KYBER_N], skpv[KYBER_N:KYBER_N], skpv[2*KYBER_N:KYBER_N], e[0:KYBER_N] = poly_getnoise_4x(skpv[0:KYBER_N], skpv[KYBER_N:KYBER_N], skpv[2*KYBER_N:KYBER_N], e[0:KYBER_N], noiseseed, nonce);

  nonce = 4;
  e[KYBER_N:KYBER_N], e[2*KYBER_N:KYBER_N], pkpv[0:KYBER_N], pkpv[KYBER_N:KYBER_N] = poly_getnoise_4x(e[KYBER_N:KYBER_N], e[2*KYBER_N:KYBER_N], pkpv[0:KYBER_N], pkpv[KYBER_N:KYBER_N], noiseseed, nonce);

  skpv = polyvec_ntt(skpv);
  e    = polyvec_ntt(e);

  pkpv[0:KYBER_N] = polyvec_pointwise_acc(pkpv[0:KYBER_N], aa[0:KYBER_VECN], skpv);
  pkpv[0:KYBER_N] = poly_frommont(pkpv[0:KYBER_N]);
  pkpv[KYBER_N:KYBER_N] = polyvec_pointwise_acc(pkpv[KYBER_N:KYBER_N], aa[KYBER_VECN:KYBER_VECN], skpv);
  pkpv[KYBER_N:KYBER_N] = poly_frommont(pkpv[KYBER_N:KYBER_N]);
  pkpv[2*KYBER_N:KYBER_N] = polyvec_pointwise_acc(pkpv[2*KYBER_N:KYBER_N], aa[2*KYBER_VECN:KYBER_VECN], skpv);
  pkpv[2*KYBER_N:KYBER_N] = poly_frommont(pkpv[2*KYBER_N:KYBER_N]);

  pkpv = polyvec_add2(pkpv, e);
  pkpv = polyvec_reduce(pkpv);

  pkp = spkp;
  skp = sskp;

  polyvec_tobytes_avx(skp, skpv);
  polyvec_tobytes_avx(pkp, pkpv);

  i = 0;
  pkp += KYBER_POLYVECBYTES; 
  while (i < KYBER_SYMBYTES/8)
  {
    j = publicseed[u64 (int)i];
    (u64)[pkp] = j;
    pkp += 8;
    i += 1;
  }

  i <<= 3;

  while (i < KYBER_SYMBYTES)
  {
    c = publicseed[(int)i];
    (u8)[pkp] = c;
    pkp += 1;
    i += 1;
  }
}


export fn indcpa_enc_jazz(reg u64 ctp, reg u64 msgp, reg u64 pkp, reg u64 coinsp)
{
  stack u16[KYBER_VECN] pkpv sp ep bp;
  stack u16[KYBER_K*KYBER_VECN] aat;
  stack u16[KYBER_N] k poly epp v poly0 poly1 poly2;
  stack u8[KYBER_SYMBYTES] publicseed;
  stack u8[KYBER_SYMBYTES] noiseseed;
  reg u64 i j;
  reg u16 t;
  reg u8 c nonce;
  stack u64 sctp;

  sctp = ctp;

  i = 0;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[coinsp+i];
    noiseseed[(int)i] = c;
    i += 1;
  }

  pkpv = polyvec_frombytes_avx(pkp);

  i = 0;
  pkp += KYBER_POLYVECBYTES;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[pkp];
    publicseed[(int)i] = c;
    pkp += 1;
    i += 1;
  }

  k = poly_frommsg_avx(k, msgp);

  aat = gen_matrix(publicseed, 1);

  nonce = 0;
  sp[0:KYBER_N], sp[KYBER_N:KYBER_N], sp[2*KYBER_N:KYBER_N], ep[0:KYBER_N] = poly_getnoise_4x(sp[0:KYBER_N], sp[KYBER_N:KYBER_N], sp[2*KYBER_N:KYBER_N], ep[0:KYBER_N], noiseseed, nonce);

  nonce = 4;
  ep[KYBER_N:KYBER_N], ep[2*KYBER_N:KYBER_N], epp, bp[0:KYBER_N] = poly_getnoise_4x(ep[KYBER_N:KYBER_N], ep[2*KYBER_N:KYBER_N], epp, bp[0:KYBER_N], noiseseed, nonce);

  sp = polyvec_ntt(sp);
    
  bp[0:KYBER_N] = polyvec_pointwise_acc(bp[0:KYBER_N], aat[0:KYBER_VECN], sp);
  bp[KYBER_N:KYBER_N]= polyvec_pointwise_acc(bp[KYBER_N:KYBER_N], aat[KYBER_VECN:KYBER_VECN], sp);
  bp[2*KYBER_N:KYBER_N] = polyvec_pointwise_acc(bp[2*KYBER_N:KYBER_N], aat[2*KYBER_VECN:KYBER_VECN], sp);
  
  v = polyvec_pointwise_acc(v, pkpv, sp);

  bp = polyvec_invntt(bp);
  v = poly_invntt(v);

  bp = polyvec_add2(bp, ep);
  v = poly_add2(v, epp);
  v = poly_add2(v, k);
  bp = polyvec_reduce(bp);
  v  = poly_reduce(v);

  ctp = sctp;
  polyvec_compress_avx(ctp, bp);
  ctp += KYBER_POLYVECCOMPRESSEDBYTES;
  v = poly_compress_avx(ctp, v);
}


export fn indcpa_dec_jazz(reg u64 msgp, reg u64 ctp, reg u64 skp)
{
  stack u16[KYBER_N] t v mp;
  stack u16[KYBER_VECN] bp skpv;

  bp = polyvec_decompress_avx(ctp);
  ctp += KYBER_POLYVECCOMPRESSEDBYTES;
  v = poly_decompress_avx(v, ctp);

  skpv = polyvec_frombytes_avx(skp);
  
  bp = polyvec_ntt(bp);
  t = polyvec_pointwise_acc(t, skpv, bp);
  t = poly_invntt(t );

  mp = poly_sub(mp, v, t);
  mp = poly_reduce(mp);
  
  mp = poly_tomsg_avx(msgp, mp);
}
