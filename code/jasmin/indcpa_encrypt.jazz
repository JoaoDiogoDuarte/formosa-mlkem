#include "params.jahh"
#include "poly_compress.jahh"
#include "poly_decompress.jahh"
#include "poly_tobytes.jahh"
#include "poly_frombytes.jahh"
#include "poly_tomsg.jahh"
#include "poly_frommsg.jahh"
#include "poly_add.jahh"
#include "poly_ntt.jahh"
#include "poly_invntt.jahh"
#include "poly_basemul.jahh"
#include "poly_frommont.jahh"
#include "poly_reduce.jahh"
#include "poly_csubq.jahh"
#include "poly_getnoise.jahh"
#include "polyvec_compress.jahh"
#include "polyvec_frombytes.jahh"
#include "polyvec_add.jahh"
#include "polyvec_pointwise_acc.jahh"
#include "polyvec_ntt.jahh"
#include "polyvec_invntt.jahh"
#include "polyvec_csubq.jahh"
#include "polyvec_reduce.jahh"
#include "gen_matrix.jahh"


export fn indcpa_enc_jazz(reg u64 ctp, reg u64 msgp, reg u64 pkp, reg u64 coinsp, reg u64 zetasp, reg u64 zetasinvp)
{
  stack u16[KYBER_VECN] pkpv at0 at1 at2 sp ep bp;
  stack u16[KYBER_N] k poly epp v;
  stack u8[KYBER_SYMBYTES] publicseed;
  stack u8[KYBER_SYMBYTES] noiseseed;
  reg u64 i j one;
  reg u16 t;
  reg u8 c nonce;

  i = 0;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[coinsp+i];
    noiseseed[(int)i] = c;
    i += 1;
  }

  pkpv = polyvec_frombytes(pkp);

  i = 0;
  pkp += KYBER_POLYVECBYTES;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[pkp];
    publicseed[(int)i] = c;
    pkp += 1;
    i += 1;
  }

  k = poly_frommsg(msgp);

  one = 1;
  at0, at1, at2 = gen_matrix(publicseed, one);


  nonce = 0;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    sp[(int)i] = t;
    i += 1;
  }

  nonce = 1;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    sp[(int)j] = t;
    i += 1;
    j += 1;
  }

  nonce = 2;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = 2*KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    sp[(int)j] = t;
    i += 1;
    j += 1;
  }


  nonce = 3;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    ep[(int)i] = t;
    i += 1;
  }

  nonce = 4;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    ep[(int)j] = t;
    i += 1;
    j += 1;
  }

  nonce = 5;
  poly = poly_getnoise(noiseseed, nonce);
  i = 0;
  j = 2*KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    ep[(int)j] = t;
    i += 1;
    j += 1;
  }

  nonce = 6;
  epp = poly_getnoise(noiseseed, nonce);

  sp = polyvec_ntt(sp, zetasp);
    
    
  poly = polyvec_pointwise_acc(at0, sp, zetasp);
  i = 0;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    bp[(int)i] = t;
    i += 1;
  }
  poly = polyvec_pointwise_acc(at1, sp, zetasp);
  i = 0;
  j = KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    bp[(int)j] = t;
    i += 1;
    j += 1;
  }
  poly = polyvec_pointwise_acc(at2, sp, zetasp);
  i = 0;
  j = 2*KYBER_N;
  while (i < KYBER_N)
  {
    t = poly[(int)i];
    bp[(int)j] = t;
    i += 1;
    j += 1;
  }
  
  v = polyvec_pointwise_acc(pkpv, sp, zetasp);

  bp = polyvec_invntt(bp, zetasinvp);
  v = poly_invntt(v, zetasinvp);

  bp = polyvec_add(bp, ep);
  v = poly_add(v, epp);
  v = poly_add(v, k);
  bp = polyvec_reduce(bp);
  v  = poly_reduce(v);

  polyvec_compress(ctp, bp);
  ctp += KYBER_POLYVECCOMPRESSEDBYTES;
  poly_compress(ctp, v);
}
