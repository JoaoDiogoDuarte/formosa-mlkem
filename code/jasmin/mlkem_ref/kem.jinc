require "indcpa.jinc"
require "verify.jinc"

inline
fn __crypto_kem_keypair_jazz(
    reg ptr u8[MLKEM_PUBLICKEYBYTES] pk,
    reg ptr u8[MLKEM_SECRETKEYBYTES] sk,
    reg ptr u8[MLKEM_SYMBYTES*2] randomnessp)
    -> reg ptr u8[MLKEM_PUBLICKEYBYTES], reg ptr u8[MLKEM_SECRETKEYBYTES]
{

  stack u8[32] h_pk;
  stack u8[MLKEM_SECRETKEYBYTES] sk2;
  reg u8 t;
  inline int i;

  pk, sk = __indcpa_keypair(pk, sk, randomnessp[0:MLKEM_SYMBYTES]);

  () = #spill(pk, sk);

  for i = 0 to MLKEM_PUBLICKEYBYTES {
      t = pk[i];
      sk2[MLKEM_POLYVECBYTES + i] = t;
  }
  () = #spill(t);

  h_pk = _sha3_256_1184(h_pk, pk);

  () = #unspill(t);
  for i = 0 to MLKEM_SYMBYTES {
      t = h_pk[i];
      sk2[MLKEM_POLYVECBYTES + MLKEM_PUBLICKEYBYTES + i] = t;
  }

  for i = 0 to MLKEM_SYMBYTES {
      t = randomnessp[i + MLKEM_SYMBYTES];
      sk2[MLKEM_POLYVECBYTES + MLKEM_PUBLICKEYBYTES + MLKEM_SYMBYTES + i] = t;
  }

  () = #unspill(sk, pk);

  for i = 0 to MLKEM_SECRETKEYBYTES {
      t = sk2[i];
      sk[i] = t;
  }

  return pk, sk;

}

inline
fn __crypto_kem_enc_jazz(
    reg ptr u8[MLKEM_CT_LEN] ct,
    reg ptr u8[MLKEM_SYMBYTES] shk,
    reg ptr u8[MLKEM_PUBLICKEYBYTES] pk,
    reg ptr u8[MLKEM_SYMBYTES] randomnessp)
    -> reg ptr u8[MLKEM_CT_LEN], reg ptr u8[MLKEM_SYMBYTES]
{
  inline int i;
  stack u8[MLKEM_SYMBYTES * 2] kr buf;
  reg u64 t64;

  () = #spill(ct, shk, pk, randomnessp);

  for i=0 to MLKEM_SYMBYTES/8 { t64 = randomnessp[u64 i]; buf[u64 i] = t64; }

  () = #spill(t64);

  buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES] = _sha3_256_1184(buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES], pk);

  kr = _sha3_512_64(kr, buf);

  () = #unspill(ct);

  ct = __indcpa_enc(ct, buf[0:MLKEM_SYMBYTES], pk, kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  () = #unspill(shk, t64);

  for i=0 to MLKEM_SYMBYTES/8 { t64 = kr[u64 i]; shk[u64 i] = t64;}

  () = #spill(ct, shk);

  return ct, shk;
}

inline
fn __crypto_kem_dec_jazz(
    reg ptr u8[MLKEM_SYMBYTES] shk,
    reg ptr u8[MLKEM_CT_LEN] ct,
    reg ptr u8[MLKEM_SECRETKEYBYTES] sk)
    -> reg ptr u8[MLKEM_SYMBYTES]
{
  stack u8[MLKEM_CT_LEN] ct2;
  stack u8[2*MLKEM_SYMBYTES] kr buf;
  reg u64 cnd;
  reg u8 t64;
  inline int i;

  () = #spill(sk, ct, shk);

  buf[0:MLKEM_MSGBYTES] = __indcpa_dec(buf[0:MLKEM_MSGBYTES], ct, sk);

  for i = 0 to MLKEM_SYMBYTES{
      t64 = sk[i + MLKEM_SECRETKEYBYTES-2*MLKEM_SYMBYTES];
      buf[i + MLKEM_SYMBYTES] = t64;
  }
  () = #spill(t64);

  kr = _sha3_512_64(kr, buf);

  ct2 = __indcpa_enc(ct2, buf[0:MLKEM_SYMBYTES], sk[MLKEM_POLYVECBYTES:MLKEM_PUBLICKEYBYTES], kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  cnd = __verify(ct, ct2);

  () = #spill(cnd);
  () = #unspill(shk);

  shk = _shake256_32_1120(shk, sk[MLKEM_SECRETKEYBYTES-MLKEM_SYMBYTES:MLKEM_SYMBYTES], ct);

  shk = __cmov(shk, kr[0:MLKEM_SYMBYTES], cnd);

  return shk;
}
