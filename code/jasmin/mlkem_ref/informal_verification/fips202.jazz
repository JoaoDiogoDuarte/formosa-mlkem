require "common.jinc"
require "fips202/reg_fips202.jinc"
require "fips202/stack_fips202.jinc"

fn stack_sha3_512_32_jazz() -> reg u8[64]
{
  stack u8[32] in;
  stack u8[64] out;
  reg u8[64] outp;
  reg u8 c;
  inline int i;

  in = IN_BYTES_32u8;

  out = _stack_sha3_512_32(out, in);

  for i = 0 to 64 {
    c = out[i];
    outp[i] = c;
  }
  return outp;
}


fn reg_sha3_512_32_jazz() -> reg u8[64]
{
  stack u8[32] in;
  stack u8[64] out;
  reg u8[64] outp;
  reg u8 c;
  inline int i;

  in = IN_BYTES_32u8;

  out = _reg_sha3_512_32(out, in);

  for i = 0 to 64 {
    c = out[i];
    outp[i] = c;
  }
  return outp;
}

fn informal_verification_sha3_512_32_jazz() -> reg bool
{
  reg bool success;
  stack u8[64] fromreg fromstack;
  fromreg = reg_sha3_512_32_jazz();
  fromstack = stack_sha3_512_32_jazz();

  success = check64u8(fromreg, fromstack);
  return success;
}

fn stack_shake256_128_33_jazz() -> reg u8[128]
{
  stack u8[33] in;
  stack u8[128] out;
  reg u8[128] outp;
  reg u64 c;
  inline int i;

  in = IN_BYTES_33u8;

  out = _stack_shake256_128_33(out, in);

  for i = 0 to 16 {
    c = out[u64 i];
    outp[u64 i] = c;
  }
  return outp;
}

fn reg_shake256_128_33_jazz() -> reg u8[128]
{
  stack u8[33] in;
  stack u8[128] out;
  reg u8[128] outp;
  reg u64 c;
  inline int i;

  in = IN_BYTES_33u8;

  out = _reg_shake256_128_33(out, in);

  for i = 0 to 16 {
    c = out[u64 i];
    outp[u64 i] = c;
  }
  return outp;
}

fn informal_verification_shake256_128_33_jazz() -> reg bool
{
  reg bool success;
  stack u8[128] fromreg fromstack;
  fromreg = reg_shake256_128_33_jazz();
  fromstack = stack_shake256_128_33_jazz();

  success = check128u8(fromreg, fromstack);
  return success;
}

fn stack_sha3_512_64_jazz() -> reg u8[64]
{
  stack u8[64] in;
  stack u8[64] out;
  reg u8[64] outp;
  reg u8 c;
  inline int i;

  in = IN_BYTES_64u8;

  out = _stack_sha3_512_64(out, in);

  for i = 0 to 64 {
    c = out[i];
    outp[i] = c;
  }
    return outp;
}

fn reg_sha3_512_64_jazz() -> reg u8[64]
{
  stack u8[64] in;
  stack u8[64] out;
  reg u8[64] outp;
  reg u8 c;
  inline int i;

  in = IN_BYTES_64u8;

  out = _reg_sha3_512_64(out, in);

  for i = 0 to 64 {
    c = out[i];
    outp[i] = c;
  }
    return outp;
}

fn informal_verification_sha3_512_64_jazz() -> reg bool
{
  reg bool success;
  stack u8[64] fromreg fromstack;
  fromreg = reg_sha3_512_64_jazz();
  fromstack = stack_sha3_512_64_jazz();

  success = check64u8(fromreg, fromstack);
  return success;
}

fn stack_shake128_squeezeblock_jazz() -> reg u8[SHAKE128_RATE]
{
  stack u64[25] state;
  stack u8[SHAKE128_RATE] out;
  reg u8[SHAKE128_RATE] outp;
  reg u8 c;
  inline int i;
  state = IN_BYTES_25u64;

  state, out = _stack_shake128_squeezeblock(state, out);

  for i = 0 to SHAKE128_RATE {
    c = out[i];
    outp[i] = c;
  }
    return outp;

}

fn reg_shake128_squeezeblock_jazz() -> reg u8[SHAKE128_RATE]
{
  stack u64[25] state;
  stack u8[SHAKE128_RATE] out;
  reg u8[SHAKE128_RATE] outp;
  reg u8 c;
  reg u64 t;
  inline int i;

  state = IN_BYTES_25u64;

  state, out = _reg_shake128_squeezeblock(state, out);

  for i = 0 to SHAKE128_RATE {
    c = out[i];
    outp[i] = c;
  }
    return outp;

}

fn informal_verification_shake128_absorb34_jazz() -> reg bool
{
  reg bool success;
  stack u8[SHAKE128_RATE] fromreg fromstack;
  fromreg = reg_shake128_squeezeblock_jazz();
  fromstack = stack_shake128_squeezeblock_jazz();

  success = check168u8(fromreg, fromstack);
  return success;
}

exec stack_shake256_128_33_jazz()
exec reg_shake256_128_33_jazz()
exec informal_verification_shake256_128_33_jazz()

//exec stack_sha3_512_32_jazz()
//exec reg_sha3_512_32_jazz()
//exec informal_verification_sha3_512_32_jazz()
