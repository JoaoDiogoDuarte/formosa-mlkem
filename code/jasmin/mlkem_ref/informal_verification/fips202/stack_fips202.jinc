require "common.jinc"

inline fn stack_keccakf1600_index(inline int x y) -> inline int // GOOD
{
  inline int r;
  r = (x % 5) + 5 * (y % 5);
  return r;
}

// C[x] = A[x,0] ^ A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
inline fn stack_keccakf1600_theta_sum(reg ptr u64[5] c, reg ptr u64[25] a) -> reg ptr u64[5] // GOOD
{
  inline int x y;
  reg u64 t64;
  () = #spill(a);

  // C[x] = A[x, 0]
  for x=0 to 5
  { t64 = a[x + 0]; c[x] = t64;  }

  // C[x] ^= A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
  for y=1 to 5
  { for x=0 to 5
  { t64 = a[x + y*5]; c[x] ^= t64; }
  }
  () = #spill(c, t64);
  return c;
}

// D[x] = C[x-1] ^ ROT(C[x+1], 1)
inline fn stack_keccakf1600_theta_rol(reg ptr u64[5] d, reg ptr u64[5] c) -> reg ptr u64[5] // GOOD
{
  inline int x;
  reg u64 t64;
  () = #spill(c);


  for x = 0 to 5
  { // D[x] = C[x + 1]
    t64 = c[(x + 1) % 5];
    d[x] = t64;

    // D[x] = ROT(D[x], 1)
    _, _, d[x] = #ROL_64(d[x], 1);

    // D[x] ^= C[x-1]
    t64 = c[(x - 1 + 5) % 5];
    d[x] ^= t64;
  }
  () = #spill(d, t64);
  return d;
}

// B[x] = ROT( (A[x',y'] ^ D[x']), r[x',y'] ) with (x',y') = M^-1 (x,y)
//
// M = (0 1)  M^-1 = (1 3)  x' = 1x + 3y
//     (2 3)         (1 0)  y' = 1x + 0y
//
inline fn stack_keccakf1600_rol_sum( // GOOD
  reg ptr u64[5] b,
  reg ptr u64[25] a,
  reg ptr u64[5] d,
  inline int y)
  ->
  reg ptr u64[5]
{
  () = #spill(b, a, d);

  inline int r x x_ y_ i;
  reg u64 t64;
  for x = 0 to 5
  {
    x_ = (x + 3*y) % 5;
    y_ = x;
    i = stack_keccakf1600_index(x_, y_);
    r = RHO_OFFSETS[i];

    // B[x] = A[x',y']
    t64 = a[x_ + y_*5];
    b[x] = t64;

    // B[x] ^= D[x'];
    t64 = d[x_];
    b[x] ^= t64;

    // B[x] = ROT( B[x], r[x',y'] );
    if(r != 0)
    { _, _, b[x] = #ROL_64(b[x], r); }
    () = #spill(t64, b);
  }
  return b;
}

// E[x, y] = B[x] ^ ( (!B[x+1]) & B[x+2] )
// -- when x and y are 0: E[0,0] ^= RC[i];
inline fn stack_keccakf1600_set_row(
  reg ptr u64[25] e,
  reg ptr u64[5] b,
  inline int y,
  stack u64 s_rc)
  ->
  reg ptr u64[25]
{
  inline int x x1 x2;
  reg u64 t;
  () = #spill(e, b);

  for x=0 to 5
  {
    x1 = (x + 1) % 5;
    x2 = (x + 2) % 5;

    // t  = !b[x1] & b[x2]; // bmi1
    t = b[x1]; t = !t; t &= b[x2];

    t ^= b[x];
    if( x==0 && y==0 ){ t ^= s_rc; }
    () = #spill(t);
    () = #unspill(e);
    e[x + y*5] = t;
    () = #spill(e);
    () = #unspill(t);
  }

  () = #spill(t, e);

  return e;
}



inline fn stack_keccakf1600_round(
  reg ptr u64[25] e,
  reg ptr u64[25] a,
  stack u64 s_rc)
  ->
  reg ptr u64[25]
{
  inline int y;
  reg ptr u64[5] b c d;
  stack u64[5] s_b s_c s_d;
  b = s_b;
  c = s_c;
  d = s_d;

  c = stack_keccakf1600_theta_sum(c, a);
  d = stack_keccakf1600_theta_rol(d, c);
  () = #spill(c, d, e);

  for y = 0 to 5
  { b = stack_keccakf1600_rol_sum(b, a, d, y);
    () = #unspill(e);
    () = #spill(b);
    e = stack_keccakf1600_set_row(e, b, y, s_rc);
    () = #spill(e);
    () = #unspill(b);
  }

  () = #spill(b);
  () = #unspill(e);
  return e;
}

inline fn __stack_keccakf1600(reg ptr u64[25] a) -> reg ptr u64[25]
{
  reg ptr u64[25] e;
  stack u64[25] s_e;
  inline int i;
  e = s_e;

  () = #spill(a);

  for i = 0 to KECCAK_ROUNDS/2
  {
    e = stack_keccakf1600_round(e, a, KECCAK1600_RC[(int) 2*i]);

    () = #spill(e);
    () = #unspill(a);

    a = stack_keccakf1600_round(a, e, KECCAK1600_RC[(int) 2*i + 1]);

    () = #spill(a);
    () = #unspill(e);

  }

  return a;
}


fn _stack_keccakf1600(reg ptr u64[25] a) -> reg ptr u64[25]
{
  a = __stack_keccakf1600(a);
  return a;
}

inline fn _stack_keccakf1600_(reg ptr u64[25] a) -> reg ptr u64[25]
{
  a = a;
  a = _stack_keccakf1600(a);
  a = a;
  () = #spill(a);
  return a;
}

inline
fn __stack_st0(reg ptr u64[25] state) -> reg ptr u64[25]
{
  inline int i;

  for i = 0 to 25 {
    state[i] = 0;
  }
  () = #spill(state);
  return state;
}

fn _stack_sha3_512_32(reg ptr u8[64] out, reg ptr u8[32] in) -> stack u8[64]
{
  stack u64[25] state;
  reg u64 t;
  inline int i;

  () = #spill(out, in);

  state = __stack_st0(state);

  for i = 0 to 4 {
    t = in[u64 i];
    state[i] ^= t;
  }
  () = #spill(t);

  state[u8 32] ^= 0x06;
  state[u8 SHA3_512_RATE-1] ^= 0x80;

  state = _stack_keccakf1600_(state);

  () = #unspill(t, out);

  for i = 0 to 8 {
    t = state[i];
    out[u64 i] = t;
  }
  () = #spill(t);

  return out;
}


fn _stack_sha3_256_1184(reg ptr u8[32] out, reg ptr u8[MLKEM_PUBLICKEYBYTES] in) -> reg ptr u8[32]
{
  stack u64[25] state;
  reg u8 t;
  reg u64 t64;
  inline int i j pos;

  () = #spill(out, in);

  pos = 0;
  state = __stack_st0(state);

  () = #spill(t);
  for i = 0 to 8 // floor(1184/136) = 8
  {
    () = #unspill(t);

    for j = 0 to SHA3_256_RATE // TODO compress for loop
    {
        t = in[pos + i];
        state[u8 i] ^= t;
        j = j + 1;
    }
    () = #spill(t);

     pos += SHA3_256_RATE;
     state = _stack_keccakf1600_(state);
  }

  () = #unspill(t);
  for i = 0 to 96
  {
    t = in[pos + i];
    state[u8 i] ^= t;
    i = i + 1;
  }
  () = #spill(t);

  state[u8 96] ^= 0x06;

  i = SHA3_256_RATE-1;
  state[u8 i] ^= 0x80;

  state = _stack_keccakf1600_(state);

  () = #unspill(out);
  for i=0 to 4
  {
    t64 = state[i];
    out[u64 i] = t64;
  }
  () = #spill(t64);

  return out;
}

fn _stack_shake128_absorb34(reg ptr u64[25] state, reg const ptr u8[34] in) -> reg ptr u64[25]
{
  reg u8 c;
  inline int i;
  () = #spill(in);

  state = __stack_st0(state);

  for i = 0 to 34 {
    c = in[i];
    state[u8 i] ^= c;
  }
  () = #spill(c);
  state[u8 34] ^= 0x1f;
  state[u8 SHAKE128_RATE-1] ^= 0x80;

  return state;
}


fn _stack_shake256_128_33(reg ptr u8[128] out, reg ptr u8[33] in) -> stack u8[128]
{
  stack u64[25] state;
  reg u64 t;
  reg u8 c;
  inline int i;

  () = #spill(out, in);

  state = __stack_st0(state);

  for i = 0 to 4 {
    t = in[u64 i];
    state[i] ^= t;
  }
  () = #spill(t);

  c = in[32];
  state[u8 32] = c;
  () = #spill(c);
  state[u8 33] ^= 0x1f;

  state[u8 SHAKE256_RATE-1] ^= 0x80;

  state = _stack_keccakf1600_(state);

  () = #unspill(out, t);
  for i = 0 to 16 {
    t = state[i];
    out[u64 i] = t;
  }
  () = #spill(t);
  return out;
}

fn _stack_shake256_32_1120(reg ptr u8[MLKEM_SYMBYTES] out, reg ptr u8[MLKEM_SYMBYTES] in0, reg ptr u8[MLKEM_CT_LEN] in1) -> reg ptr u8[32] {
  stack u64[25] state;
  stack u8[MLKEM_CT_LEN] in;
  reg u64 t64;
  inline int i j pos;

  () = #spill(out, in0, in1);

  state = __stack_st0(state);

  for i = 0 to MLKEM_SYMBYTES/8 {
    t64 = in0[u64 i];
    state[u64 i] ^= t64;
  }

  for i = MLKEM_SYMBYTES/8 to SHAKE256_RATE/8 {
    t64 = in1.[u64 (i-MLKEM_SYMBYTES/8)*8];
    state[u64 i] ^= t64;
  }

  () = #spill(t64);

  state = _stack_keccakf1600_(state);

  () = #unspill(t64);

  for i = (SHAKE256_RATE - MLKEM_SYMBYTES)/8 to MLKEM_CT_LEN/8 {
    t64 = in1[u64 i];
    in.[u64 (i-(SHAKE256_RATE - MLKEM_SYMBYTES)/8)*8] = t64;
  }

  () = #spill(t64);

  pos = 0;

  for i = 0 to 6
  {
    () = #unspill(t64);
    for j = 0 to SHA3_256_RATE/8
    {
      t64 = in.[u64 (i+pos/8)*8];
      state[u64 i] ^= t64;
      j = j + 1;
    }

    () = #spill(t64);

    pos += SHA3_256_RATE;
    state = _stack_keccakf1600_(state);
  }

  () = #unspill(t64);

  for i = 0 to 12
  {
    t64 = in.[u64 (i+pos/8)*8];
    state[u64 i] ^= t64;
    i = i + 1;
  }

  () = #spill(t64);

  state[u8 96] ^= 0x1f;

  i = SHAKE256_RATE-1;
  state[u8 i] ^= 0x80;

  state = _stack_keccakf1600_(state);

  () = #unspill(out, t64);

  for i=0 to MLKEM_SYMBYTES/8
  {
    t64 = state[i];
    out[u64 i] = t64;

  }

  () = #spill(t64);
  return out;
}


fn _stack_shake128_squeezeblock(reg ptr u64[25] state, reg ptr u8[SHAKE128_RATE] out) -> reg ptr u64[25], reg ptr u8[SHAKE128_RATE]
{
  reg u8 c;
  inline int i;
  () = #spill(out);
  state = _stack_keccakf1600_(state);
  () = #spill(state);
  () = #unspill(out);
  for i = 0 to SHAKE128_RATE {
    c = state[u8 (int) i];
    out[i] = c;
  }
  () = #spill(c);
  return state, out;
}


#[returnaddress="stack"]
fn _stack_sha3_512_64(reg ptr u8[64] out, reg const ptr u8[64] in) -> stack u8[64]
{
  stack u64[25] state;
  reg u64 t64;
  inline int i;

  () = #spill(out);

  state = __stack_st0(state);

  for i = 0 to 8
  {
    t64 = in[u64 i];
    state[i] ^= t64;
  }

  () = #spill(t64, in);

  state[u8 64] ^= 0x06;
  state[u8 SHA3_512_RATE - 1] ^= 0x80;

  state = _stack_keccakf1600_(state);

  () = #unspill(t64, out);
  for i = 0 to 8
  {
    t64 = state[i];
    out[u64 i] = t64;
  }
  () = #spill(t64);
  return out;
}
