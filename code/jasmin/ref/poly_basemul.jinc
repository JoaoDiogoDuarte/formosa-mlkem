require "params.jinc"
require "reduce.jinc"

fn _poly_basemul(reg ptr u16[KYBER_N] rp, reg const ptr u16[KYBER_N] ap bp) -> reg ptr u16[KYBER_N]
{
  reg u64 offset;
  reg u16 zeta;
  reg u16 r0;
  reg u16 r1;
  reg u16 a0;
  reg u16 a1;
  reg u16 b0;
  reg u16 b1;
  reg u16 t;
  reg ptr u16[128] zetasp;
  reg u64 zetasctr;
  reg u64 i;

  stack ptr u16[KYBER_N] srp;

  srp = rp;

  zetasctr = 64;
  i = 0;

  while(i < KYBER_N)
  {
    zetasp = jzetas;
    zeta = zetasp[(int)zetasctr];
    zetasctr += 1;
    
    a0 = ap[(int)i];
    b0 = bp[(int)i];
    i += 1;
    a1 = ap[(int)i];
    b1 = bp[(int)i];
    i -= 1;

    r0 = __fqmul(a1, b1);
    r0 = __fqmul(r0, zeta);
    t  = __fqmul(a0, b0);
    r0 += t;

    r1 = __fqmul(a0, b1);
    t  = __fqmul(a1, b0);
    r1 += t;

    rp = srp;
    rp[(int)i]   = r0;
    i += 1;
    rp[(int)i] = r1;
    srp = rp;


    zeta = -zeta;

    i += 1;
    a0 = ap[(int)i];
    b0 = bp[(int)i];
    i += 1;
    a1 = ap[(int)i];
    b1 = bp[(int)i];
    i -= 1;

    r0 = __fqmul(a1, b1);
    r0 = __fqmul(r0, zeta);
    t  = __fqmul(a0, b0);
    r0 += t;

    r1 = __fqmul(a0, b1);
    t  = __fqmul(a1, b0);
    r1 += t;

    rp = srp;
    rp[(int)i]   = r0;
    i += 1;
    rp[(int)i] = r1;
    srp = rp;
    
    i += 1;
  }
  return rp;
}
