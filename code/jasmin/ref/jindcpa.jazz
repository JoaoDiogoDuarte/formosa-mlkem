require "params.jinc"
require "poly_compress.jinc"
require "poly_decompress.jinc"
require "poly_tobytes.jinc"
require "poly_frombytes.jinc"
require "poly_tomsg.jinc"
require "poly_frommsg.jinc"
require "poly_add2.jinc"
require "poly_sub.jinc"
require "poly_ntt.jinc"
require "poly_invntt.jinc"
require "poly_basemul.jinc"
require "poly_frommont.jinc"
require "poly_reduce.jinc"
require "poly_csubq.jinc"
require "poly_getnoise.jinc"
require "polyvec_tobytes.jinc"
require "polyvec_frombytes.jinc"
require "polyvec_compress.jinc"
require "polyvec_decompress.jinc"
require "polyvec_add2.jinc"
require "polyvec_pointwise_acc.jinc"
require "polyvec_ntt.jinc"
require "polyvec_invntt.jinc"
require "polyvec_csubq.jinc"
require "polyvec_reduce.jinc"
require "polyvec_frompolys.jinc"
require "polyvec_topolys.jinc"
require "gen_matrix.jinc"


export fn indcpa_keypair_jazz(reg u64 pkp, reg u64 skp, reg u64 randomnessp)
{
  stack u16[KYBER_VECN] a0 a1 a2 e pkpv skpv;
  stack u16[KYBER_N] poly0 poly1 poly2;
  stack u8[64] buf;
  stack u8[KYBER_SYMBYTES] publicseed noiseseed;
  stack u8[32] inbuf;
  reg u8 c;
  reg u64 zero;
  reg u8 nonce;
  reg u64 i, j;

  stack u64 spkp;
  stack u64 sskp;

  spkp = pkp;
  sskp = skp;

  i = 0;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[randomnessp + i];
    inbuf[(int) i] = c;
    i += 1;
  }

  buf = _sha3512_32(buf, inbuf);

  i = 0;
  j = KYBER_SYMBYTES;
  while (i < KYBER_SYMBYTES)
  {
    c = buf[(int)i];
    publicseed[(int)i] = c;
    c = buf[(int)j];
    noiseseed[(int)i] = c;
    i += 1;
    j += 1;
  }

  zero = 0; 
  a0, a1, a2 = __gen_matrix(publicseed, zero);

  nonce = 0;
  poly0 = _poly_getnoise(poly0, noiseseed, nonce);
  nonce = 1;
  poly1 = _poly_getnoise(poly1, noiseseed, nonce);
  nonce = 2;
  poly2 = _poly_getnoise(poly2, noiseseed, nonce);
  skpv = __polyvec_frompolys(poly0, poly1, poly2);

  nonce = 3;
  poly0 = _poly_getnoise(poly0, noiseseed, nonce);
  nonce = 4;
  poly1 = _poly_getnoise(poly1, noiseseed, nonce);
  nonce = 5;
  poly2 = _poly_getnoise(poly2, noiseseed, nonce);
  e = __polyvec_frompolys(poly0, poly1, poly2);

  skpv = __polyvec_ntt(skpv);
  e    = __polyvec_ntt(e);

  poly0 = __polyvec_pointwise_acc(a0, skpv);
  poly0 = _poly_frommont(poly0);
  poly1 = __polyvec_pointwise_acc(a1, skpv);
  poly1 = _poly_frommont(poly1);
  poly2 = __polyvec_pointwise_acc(a2, skpv);
  poly2 = _poly_frommont(poly2);
  pkpv = __polyvec_frompolys(poly0, poly1, poly2);

  pkpv = __polyvec_add2(pkpv, e);
  pkpv = __polyvec_reduce(pkpv);

  pkp = spkp;
  skp = sskp;

  __polyvec_tobytes(skp, skpv);
  __polyvec_tobytes(pkp, pkpv);

  i = 0;
  pkp += KYBER_POLYVECBYTES; 
  while (i < KYBER_SYMBYTES)
  {
    c = publicseed[(int)i];
    (u8)[pkp] = c;
    pkp += 1;
    i += 1;
  }
}


export fn indcpa_enc_jazz(reg u64 ctp, reg u64 msgp, reg u64 pkp, reg u64 coinsp)
{
  stack u16[KYBER_VECN] pkpv at0 at1 at2 sp ep bp;
  stack u16[KYBER_N] k poly epp v poly0 poly1 poly2;
  stack u8[KYBER_SYMBYTES] publicseed;
  stack u8[KYBER_SYMBYTES] noiseseed;
  reg u64 i j one;
  reg u16 t;
  reg u8 c nonce;
  stack u64 sctp;

  sctp = ctp;

  i = 0;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[coinsp+i];
    noiseseed[(int)i] = c;
    i += 1;
  }

  pkpv = __polyvec_frombytes(pkp);

  i = 0;
  pkp += KYBER_POLYVECBYTES;
  while (i < KYBER_SYMBYTES)
  {
    c = (u8)[pkp];
    publicseed[(int)i] = c;
    pkp += 1;
    i += 1;
  }

  k = _poly_frommsg(k, msgp);

  one = 1;
  at0, at1, at2 = __gen_matrix(publicseed, one);


  nonce = 0;
  poly0 = _poly_getnoise(poly0, noiseseed, nonce);
  nonce = 1;
  poly1 = _poly_getnoise(poly1, noiseseed, nonce);
  nonce = 2;
  poly2 = _poly_getnoise(poly2, noiseseed, nonce);
  sp = __polyvec_frompolys(poly0, poly1, poly2);

  nonce = 3;
  poly0 = _poly_getnoise(poly0, noiseseed, nonce);
  nonce = 4;
  poly1 = _poly_getnoise(poly1, noiseseed, nonce);
  nonce = 5;
  poly2 = _poly_getnoise(poly2, noiseseed, nonce);
  ep = __polyvec_frompolys(poly0, poly1, poly2);

  nonce = 6;
  epp = _poly_getnoise(epp, noiseseed, nonce);

  sp = __polyvec_ntt(sp);
    
    
  poly0 = __polyvec_pointwise_acc(at0, sp);
  poly1 = __polyvec_pointwise_acc(at1, sp);
  poly2 = __polyvec_pointwise_acc(at2, sp);
  bp = __polyvec_frompolys(poly0, poly1, poly2);
  
  v = __polyvec_pointwise_acc(pkpv, sp);

  bp = __polyvec_invntt(bp);
  v = _poly_invntt(v);

  bp = __polyvec_add2(bp, ep);
  v = _poly_add2(v, epp);
  v = _poly_add2(v, k);
  bp = __polyvec_reduce(bp);
  v  = __poly_reduce(v);

  ctp = sctp;
  __polyvec_compress(ctp, bp);
  ctp += KYBER_POLYVECCOMPRESSEDBYTES;
  v = _poly_compress(ctp, v);
}



export fn indcpa_dec_jazz(reg u64 msgp, reg u64 ctp, reg u64 skp)
{
  stack u16[KYBER_N] t v mp;
  stack u16[KYBER_VECN] bp skpv;

  bp = __polyvec_decompress(ctp);
  ctp += KYBER_POLYVECCOMPRESSEDBYTES;
  v = _poly_decompress(v, ctp);

  skpv = __polyvec_frombytes(skp);
  
  bp = __polyvec_ntt(bp);
  t = __polyvec_pointwise_acc(skpv, bp);
  t = _poly_invntt(t );

  mp = _poly_sub(mp, v, t);
  mp = __poly_reduce(mp);
  
  mp = _poly_tomsg(msgp, mp);
}
